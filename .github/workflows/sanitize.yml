name: CI

on: [push, pull_request]

env:
  DEVELOPER: 1

jobs:
  ci-config:
    name: config
    runs-on: ubuntu-latest
    outputs:
      enabled: ${{ steps.check-ref.outputs.enabled }}${{ steps.skip-if-redundant.outputs.enabled }}
    steps:
      - name: try to clone ci-config branch
        run: |
          git -c protocol.version=2 clone \
            --no-tags \
            --single-branch \
            -b ci-config \
            --depth 1 \
            --no-checkout \
            --filter=blob:none \
            https://github.com/${{ github.repository }} \
            config-repo &&
          cd config-repo &&
          git checkout HEAD -- ci/config || : ignore
      - id: check-ref
        name: check whether CI is enabled for ref
        run: |
          enabled=yes
          if test -x config-repo/ci/config/allow-ref &&
             ! config-repo/ci/config/allow-ref '${{ github.ref }}'
          then
            enabled=no
          fi
          echo "::set-output name=enabled::$enabled"
      - name: skip if the commit or tree was already tested
        id: skip-if-redundant
        uses: actions/github-script@v3
        if: steps.check-ref.outputs.enabled == 'yes'
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            try {
              // Figure out workflow ID, commit and tree
              const { data: run } = await github.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: context.runId,
              });
              const workflow_id = run.workflow_id;
              const head_sha = run.head_sha;
              const tree_id = run.head_commit.tree_id;

              // See whether there is a successful run for that commit or tree
              const { data: runs } = await github.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 500,
                status: 'success',
                workflow_id,
              });
              for (const run of runs.workflow_runs) {
                if (head_sha === run.head_sha) {
                  core.warning(`Successful run for the commit ${head_sha}: ${run.html_url}`);
                  core.setOutput('enabled', ' but skip');
                  break;
                }
                if (run.head_commit && tree_id === run.head_commit.tree_id) {
                  core.warning(`Successful run for the tree ${tree_id}: ${run.html_url}`);
                  core.setOutput('enabled', ' but skip');
                  break;
                }
              }
            } catch (e) {
              core.warning(e);
            }

  dockerized:
    name: ${{matrix.vector.jobname}}
    needs: ci-config
    if: needs.ci-config.outputs.enabled == 'yes'
    strategy:
      fail-fast: false
      matrix:
        vector:
        - jobname: sanitize-clang
        - jobname: sanitize-gcc
    env:
      jobname: ${{matrix.vector.jobname}}
    runs-on: ubuntu-latest
    container: fedora
    steps:
    - uses: actions/checkout@v1
    - run: ci/sanitizer-install-dependencies.sh
    - run: ci/run-sanitize-build.sh --build
    - run: ci/run-sanitize-build.sh --test
    - run: ci/print-test-failures.sh
      if: failure()
    - name: Upload failed tests' directories
      if: failure() && env.FAILED_TEST_ARTIFACTS != ''
      uses: actions/upload-artifact@v1
      with:
        name: failed-tests-${{matrix.vector.jobname}}
        path: ${{env.FAILED_TEST_ARTIFACTS}}
